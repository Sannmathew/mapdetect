### maximize space within a hallway ###
# selecting two points for line
# find line
# find average distance to line
# how many are within epsilon
# repeat until k iterations, pick model with max number of inliers

#used for the square root function in distanceOfPointFromLine
import math
'''
selecting two points
- depends on location in hallway (in the middle vs to the side)
- depends on pose (facing straight down hallway vs towards the wall)
'''

'''
finding a line
- can be the mid point/line of hallway
- can extend from robot
'''

def findLineBetweenTwoPoints (x1, y1, x2, y2):
    """ Returns a tuple with information about the line
    
    The first item in the list is boolean, true = vertical line
    if true then the second item in the list is x = # of vertical line
    
    if false
    the second item is the slope of the line
    the third item is the y-intercept
    """
    lineInformationTuple = []
    #check if the line is a vertical line    
    if x1 == x2:
        lineInformationTuple.append(True)
        lineInformationTuple.append(x1)
        #Don't really need a third append here since a vertical line is x = x1
        lineInformationTuple.append(0)
    else: 
        lineInformationTuple.append(False)
        slope = (float (y2 - y1))/(float (x2 - x1))
        intercept = y1 - (slope * x1)
        lineInformationTuple.append(slope)
        lineInformationTuple.append(intercept)
    return lineInformationTuple

#Testing findingLineBetweenTwoPoints
equationOfLine = findLineBetweenTwoPoints (2,5,8,5)
print("Is vertical= " + str(equationOfLine[0]))
if equationOfLine[0] == True:
    print("x = " + str(equationOfLine[1]))
else:
    print("slope = " + str(equationOfLine[1]))
    print("y intercept = " + str(equationOfLine[2]))
#End Testing findingLineBetweenTwoPoints

def distanceOfPointFromLine(x1, y1, lineInformationList):
    """ Returns the distance from point (x1, y1) to the line created from the findLineBetweenTwoPoints """
    #check if line is a vertical Line
    if  lineInformationList[0] == True:
        #vertical line is |x1 - the-distance-of-x|
        return abs(x1 - lineInformationList[1])
    elif lineInformationList[1] == 0:
        #horizontal line is just |y1 - slopeIntercept|
        return abs(y1 - lineInformationList[2])
    else:
        #distance of point between line = |ax1 + by1 + c|/ sqrt(a^2 + b^2)
        return abs((y1 - (lineInformationList[1] * x1) - lineInformationList[2])/ math.sqrt(1 + lineInformationList[1] * lineInformationList[1]))

#Testing distanceOfPointFromLine
print(str(distanceOfPointFromLine(12,8,equationOfLine)))
#END testing distanceOFPointFromLine

def avgDistOfPointsFromLine(listOfCoordinates, lineInformationList):
    """Returns the average distance of all the points from the line"""
    sumOfDistances = 0
    for coordinatePair in listOfCoordinates:
        sumOfDistances += distanceOfPointFromLine(coordinatePair[0],coordinatePair[1],lineInformationList)
    return float(sumOfDistances) / len(listOfCoordinates)
        
#This will give us the coordinates of the points we want to use to generate lines for
def generateCoordinates(robotXPos, robotYPos, minDistOfLaser, maxDistOfLaser, startingAngle, angleIncrement, laserStride, listOfLaserReading):
    """Returns a list of coordinates where the laser distance was between the minDistOfLaser and MaxDistOfLaser, inclusive.
    
    Keyword Argumenets:
    robotXPos -- the X coordinate of the robot
    robotYPos -- the Y coordinate of the robot
    minDistOfLaser -- the minimum distance of the laser to include
    maxDistOfLaser -- the maximum distance of the laser to include
    startingAngle -- the starting angle in radians
    angleIncrement -- the angle increment for each laser
    laserStride -- the stride between the lasers?, 1 includes all lasers, 2 includes every other laser and so on
    listOfLaserReading -- the list of all the laser readings
    """
    
    listOfCoordinates = []
    currentAngleInRadian = float(startingAngle)
    for currentLaserReading in listOfLaserReading[::laserStride]:
        if (float(minDistOfLaser) <= float(currentLaserReading)) and (float(currentLaserReading) <= float(maxDistOfLaser)):
            wallX = (float(currentLaserReading) * math.cos(float(currentAngleInRadian))) + float(robotXPos)
            wallY = (float(currentLaserReading) * math.sin(float(currentAngleInRadian))) + float(robotYPos)
            wallCoorTuple = (wallX, wallY)
            listOfCoordinates.append(wallCoorTuple)
        currentAngleInRadian = currentAngleInRadian + (float(laserStride) * float(angleIncrement))
        
    return listOfCoordinates

        
def generateLines(robotXpos, robotYpos, coordinateList):
    """Returns a list of lines generated by using the robot X and Y with each coordinate tuple in coordinateList"""
    listOfLines = []
    for currentCoordinateTuple in coordinateList:
        listOfLines.append(findLineBetweenTwoPoints (robotXpos, robotYpos, currentCoordinateTuple[0], currentCoordinateTuple[1]))
    return listOfLines

    
#TESTING generateCoordinates and generateLines
laserDataFile = open('data_laser.txt','r')
robotPoseFile = open('data_pose.txt','r')
laserStrideNumber = 1

#removing header line
testLaser = laserDataFile.readline().split(",")
testPose = robotPoseFile.readline().split(",")

poseDataLineSplit = robotPoseFile.readline().split(",")
laserDataLineSplit = laserDataFile.readline().split(",")

#creating a list of laser readings
laserReaderList = []
for laser in laserDataLineSplit[11:]:
    laserReaderList.append(laser)
        
#poseDataLineSplit[4], poseDataLineSplit[5] = robotXPos and robotYPos
#laserDataLineSplit[10], = maxDistofLaser 
# laserDataLineSplit[4], = starting Angle
# laserDataLineSplit[6], = angle increment
coordinateTupleList = generateCoordinates(poseDataLineSplit[4], poseDataLineSplit[5], 25, laserDataLineSplit[10], laserDataLineSplit[4], laserDataLineSplit[6],laserStrideNumber, laserReaderList) 
    
print(coordinateTupleList)

#generate a list of lines from the coordinateTuple List
lineList = generateLines(float(poseDataLineSplit[4]), float(poseDataLineSplit[5]), coordinateTupleList)

print(lineList)
    
laserDataFile.close()
robotPoseFile.close()
#END Testing of generateCoordinates and generateLines
    
'''
average distance to line
- ransac regression-ish algorithm

how many within epsilon
- found after distance calculated for points

'''

'''

simple case: robot data we were given

take 0, 180 degree points, get midpoint, make line to 90 degree point returned ffrom data

do regression, find average distance

'''
